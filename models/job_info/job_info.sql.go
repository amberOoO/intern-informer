// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: job_info.sql

package jobInfo

import (
	"context"
	"database/sql"
)

const getJobInfoByJobNameAndCompany = `-- name: GetJobInfoByJobNameAndCompany :one
SELECT id, created_time, job_name, company, job_description, job_type, job_category, job_location, is_checked, is_exists FROM job_info
WHERE job_name = ? AND company = ? LIMIT 1
`

type GetJobInfoByJobNameAndCompanyParams struct {
	JobName string
	Company string
}

func (q *Queries) GetJobInfoByJobNameAndCompany(ctx context.Context, arg GetJobInfoByJobNameAndCompanyParams) (JobInfo, error) {
	row := q.db.QueryRowContext(ctx, getJobInfoByJobNameAndCompany, arg.JobName, arg.Company)
	var i JobInfo
	err := row.Scan(
		&i.ID,
		&i.CreatedTime,
		&i.JobName,
		&i.Company,
		&i.JobDescription,
		&i.JobType,
		&i.JobCategory,
		&i.JobLocation,
		&i.IsChecked,
		&i.IsExists,
	)
	return i, err
}

const getJobInfosByCompany = `-- name: GetJobInfosByCompany :many
SELECT id, created_time, job_name, company, job_description, job_type, job_category, job_location, is_checked, is_exists FROM job_info
WHERE company = ? LIMIT 1
`

func (q *Queries) GetJobInfosByCompany(ctx context.Context, company string) ([]JobInfo, error) {
	rows, err := q.db.QueryContext(ctx, getJobInfosByCompany, company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobInfo
	for rows.Next() {
		var i JobInfo
		if err := rows.Scan(
			&i.ID,
			&i.CreatedTime,
			&i.JobName,
			&i.Company,
			&i.JobDescription,
			&i.JobType,
			&i.JobCategory,
			&i.JobLocation,
			&i.IsChecked,
			&i.IsExists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobInfosByIsCheckedAndCompany = `-- name: GetJobInfosByIsCheckedAndCompany :many
SELECT id, created_time, job_name, company, job_description, job_type, job_category, job_location, is_checked, is_exists FROM job_info
WHERE is_checked = ? AND company = ?
`

type GetJobInfosByIsCheckedAndCompanyParams struct {
	IsChecked bool
	Company   string
}

func (q *Queries) GetJobInfosByIsCheckedAndCompany(ctx context.Context, arg GetJobInfosByIsCheckedAndCompanyParams) ([]JobInfo, error) {
	rows, err := q.db.QueryContext(ctx, getJobInfosByIsCheckedAndCompany, arg.IsChecked, arg.Company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobInfo
	for rows.Next() {
		var i JobInfo
		if err := rows.Scan(
			&i.ID,
			&i.CreatedTime,
			&i.JobName,
			&i.Company,
			&i.JobDescription,
			&i.JobType,
			&i.JobCategory,
			&i.JobLocation,
			&i.IsChecked,
			&i.IsExists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobInfosByIsExistsAndCompany = `-- name: GetJobInfosByIsExistsAndCompany :many
SELECT id, created_time, job_name, company, job_description, job_type, job_category, job_location, is_checked, is_exists FROM job_info
WHERE is_exists = ? AND company = ?
`

type GetJobInfosByIsExistsAndCompanyParams struct {
	IsExists bool
	Company  string
}

func (q *Queries) GetJobInfosByIsExistsAndCompany(ctx context.Context, arg GetJobInfosByIsExistsAndCompanyParams) ([]JobInfo, error) {
	rows, err := q.db.QueryContext(ctx, getJobInfosByIsExistsAndCompany, arg.IsExists, arg.Company)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobInfo
	for rows.Next() {
		var i JobInfo
		if err := rows.Scan(
			&i.ID,
			&i.CreatedTime,
			&i.JobName,
			&i.Company,
			&i.JobDescription,
			&i.JobType,
			&i.JobCategory,
			&i.JobLocation,
			&i.IsChecked,
			&i.IsExists,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertJobInfo = `-- name: InsertJobInfo :exec
INSERT INTO job_info (
    job_name, company, job_description, job_type, job_category, job_location
) VALUES (
    ?, ?, ?, ?, ?, ?
)ON CONFLICT(job_name, company) DO UPDATE SET is_exists = true
`

type InsertJobInfoParams struct {
	JobName        string
	Company        string
	JobDescription sql.NullString
	JobType        sql.NullString
	JobCategory    sql.NullString
	JobLocation    sql.NullString
}

func (q *Queries) InsertJobInfo(ctx context.Context, arg InsertJobInfoParams) error {
	_, err := q.db.ExecContext(ctx, insertJobInfo,
		arg.JobName,
		arg.Company,
		arg.JobDescription,
		arg.JobType,
		arg.JobCategory,
		arg.JobLocation,
	)
	return err
}

const resetIsExistsByCompany = `-- name: ResetIsExistsByCompany :exec
UPDATE job_info
SET is_exists = 0
WHERE company = ?
`

func (q *Queries) ResetIsExistsByCompany(ctx context.Context, company string) error {
	_, err := q.db.ExecContext(ctx, resetIsExistsByCompany, company)
	return err
}

const updateIsChecked = `-- name: UpdateIsChecked :exec
UPDATE job_info 
SET is_checked = ?
WHERE id = ?
`

type UpdateIsCheckedParams struct {
	IsChecked bool
	ID        int64
}

func (q *Queries) UpdateIsChecked(ctx context.Context, arg UpdateIsCheckedParams) error {
	_, err := q.db.ExecContext(ctx, updateIsChecked, arg.IsChecked, arg.ID)
	return err
}
